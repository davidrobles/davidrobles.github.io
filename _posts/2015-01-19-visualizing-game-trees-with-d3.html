---
layout:     post
title:      "Visualizing Game Trees with D3.js"
date:       2015-01-19 16:00:00
comments:   true
excerpt:    "In this post I describe a simple API for abstract strategy games and algorithms to play these games. An
interface like this one is the base of a game-playing framework and it will be used in following blog posts
to describe algorithms such as Minimax, Alpha-Beta and Monte-Carlo Tree Search."
img:        "visualizing-game-trees-with-d3/copy.png"
style:      ["visualizing-game-trees-with-d3/style.css"]
js:         ["visualizing-game-trees-with-d3/d3.js",
             "visualizing-game-trees-with-d3/underscore.js",
             "visualizing-game-trees-with-d3/backbone.js",
             "visualizing-game-trees-with-d3/mauler-0.0.4.js",
             "visualizing-game-trees-with-d3/full-static-game-tree.js"]
---

<p>
    <a href="http://d3js.org/">D3.js</a> is a JavaScript library for data visualization. It allows direct inspection and
    manipulation of the DOM, but is intended solely for data visualization. D3 is proving to be very versatile and
    powerful, thanks to the technologies upon which it is based: JavaScript, SVG, and CSS. In so doing, D3 takes full
    advantage of the capabilities of the modern browser.
</p>
<p>
    In this post I will show how to use D3.js to visualize game trees using
    <a href="https://github.com/davidrobles/mauler">Mauler</a>, the abstract strategy games framework that I described
    in a <a href="/blog/2014/08/01/mauler-a-javascript-framework-for-abstract-strategy-games/"> previous post</a>.
</p>

<h2>What is a game tree?</h2>

<p>
    In game theory, <strong>a game tree</strong> is a directed graph whose nodes are positions in a game and whose edges
    are moves. Here is a figure of a game tree in which the root node is a Tic-Tac-Toe game position and the
    first player, <span style="font-weight: bold; color: rgba(231, 76, 60, 1.0)">X</span>, is about to move next:
</p>

<div id="full-static-game-tree"></div>

<p>
    Being able to visualize game trees like this one is very useful to analyze the possible moves and outcomes to make
    better decisions. For example, in this figure we can see that:
</p>

<ul>
    <li>There are three possible moves for <span style="font-weight: bold; color: rgba(231, 76, 60, 1.0)">X</span>.</li>
    <li>There are 10 game positions that can be potentially reached from the current position.</li>
    <li>There are five leaf nodes, which means five possible endgame positions.</li>
    <li>The outcomes for the five endgame positions are:
        <ul>
            <li>Two wins for <span style="font-weight: bold; color: rgba(231, 76, 60, 1.0)">X</span>.</li>
            <li>One win for <span style="font-weight: bold; color: rgba(41, 128, 185, 1.0)">&#11044;</span>.</li>
            <li>Two draws.</li>
        </ul>
    </li>
    <li>
        If we assume perfect play by the second player, only the move to the middle-bottom square guarantees a win for
        the first player.
    </li>
</ul>

<p>
    Even in a trivial example like this, it is much easier to see these observations with a corresponding
    visualization of the game tree. Also, in the case of more complex examples, data visualization allows us see
    patterns or trends that we might have missed otherwise.
</p>

<p>Now let's walk through, step by step, how to visualize game trees with Javascript, SVGs and D3.</p>

<h2>Drawing the Tic-Tac-Toe game board</h2>

<p>First of all, we need to create an instance of a Tic-Tac-Toe game position:</p>

{% highlight javascript %}
var ticTacToe = new TicTacToe({
    board: [['O', 'X', 'O'],
            ['O', 'X', ' '],
            [' ', ' ', 'X']]
});
{% endhighlight %}

<script>
var boardLength = 150,
    squareLength = Math.floor(boardLength / 3),
    bgColor = "rgb(255, 219, 122)",
    gridColor = "rgb(229, 197, 110)";
var svgEl = document.createElement("svg");
var svg = d3.select(svgEl)
            .attr("class", "board")
            .attr("width", boardLength)
            .attr("height", boardLength);
var tic = new ma.games.TicTacToe({
    board: [['O', 'X', 'O'],
            ['O', 'X', ' '],
            [' ', ' ', 'X']]
});
</script>

<p>Then, we need to define the constants used in the SVG element for the game board:</p>

{% highlight javascript %}
var boardLength = 150,
    squareLength = Math.floor(boardLength / 3),
    bgColor = "rgb(255, 219, 122)",
    gridColor = "rgb(229, 197, 110)";
{% endhighlight %}

<p>Next, create the SVG element and set the dimensions. We will save it as a d3 selection to make things easier later:</p>

{% highlight javascript %}
var svg = d3.select(document.createElement("svg"))
                .attr("width", boardLength)
                .attr("height", boardLength);
{% endhighlight %}

<p>Fill the background:</p>

{% highlight javascript %}
svg.append("rect")
    .attr("x", 0)
    .attr("y", 0)
    .attr("width", boardLength)
    .attr("height", boardLength)
    .attr("fill", bgColor)
    .attr("stroke", "none");
{% endhighlight %}

<script>
document.write((function() {
    svg.append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", boardLength)
        .attr("height", boardLength)
        .attr("fill", bgColor)
        .attr("stroke", "none");
    return svgEl.outerHTML;
}()));
</script>

<p>Draw the grid:</p>

{% highlight javascript %}
// border
svg.append("rect")
    .attr("x", 0)
    .attr("y", 0)
    .attr("width", boardLength)
    .attr("height", boardLength)
    .attr("fill", "none")
    .attr("stroke", gridColor)
    .attr("stroke-width", 6);

// lines
for (var i = 1; i < 3; i++) {
    // vertical
    svg.append("line")
        .attr("x1", squareLength * i)
        .attr("y1", 0)
        .attr("x2", squareLength * i)
        .attr("y2", boardLength)
        .attr("stroke", borderColor)
        .attr("stroke-width", 3);
    // horizontal
    svg.append("line")
        .attr("x1", 0)
        .attr("y1", squareLength * i)
        .attr("x2", boardLength)
        .attr("y2", squareLength * i)
        .attr("stroke", borderColor)
        .attr("stroke-width", 3);
}
{% endhighlight %}

<script>
document.write((function() {

    // border
    svg.append("rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", boardLength)
            .attr("height", boardLength)
            .attr("fill", "none")
            .attr("stroke", gridColor)
            .attr("stroke-width", 6);

    // lines
    for (var i = 1; i < 3; i++) {
        // vertical
        svg.append("line")
                .attr("x1", squareLength * i)
                .attr("y1", 0)
                .attr("x2", squareLength * i)
                .attr("y2", 150)
                .attr("stroke", gridColor)
                .attr("stroke-width", 3);
        // horizontal
        svg.append("line")
                .attr("x1", 0)
                .attr("y1", squareLength * i)
                .attr("x2", boardLength)
                .attr("y2", squareLength * i)
                .attr("stroke", gridColor)
                .attr("stroke-width", 3);
    }

    return svgEl.outerHTML;
}()));
</script>

<h2>Draw Xs and Os</h2>

{% highlight javascript %}
var scale = d3.scale.ordinal().domain([0, 1, 2]).rangeRoundBands([0, 150], 1, 0.5);
var crossColor = "rgba(231, 76, 60, 1.0)";
var noughtColor = "rgba(41, 128, 185,1.0)";
for (var row = 0; row < 3; row++) {
    for (var col = 0; col < 3; col++) {
        var cellType = tic.cell(row, col);
        if (cellType === "CROSS") {
            var cellSize = 150 / 11;
            svg.append("line")
                .attr("x1", scale(col) - cellSize)
                .attr("y1", scale(row) - cellSize)
                .attr("x2", scale(col) + cellSize)
                .attr("y2", scale(row) + cellSize)
                .attr("stroke", crossColor)
                .attr("stroke-width", 150 / 30);
            svg.append("line")
                .attr("x1", scale(col) - cellSize)
                .attr("y1", scale(row) + cellSize)
                .attr("x2", scale(col) + cellSize)
                .attr("y2", scale(row) - cellSize)
                .attr("stroke", crossColor)
                .attr("stroke-width", 150 / 30);
        } else if (cellType === "NOUGHT") {
            svg.append("circle")
                .attr("cx", scale(col))
                .attr("cy", scale(row))
                .attr("r", 150 * 0.1)
                .attr("fill", noughtColor);
        }
    }
}
{% endhighlight %}

<script>
document.write((function() {
    var scale = d3.scale.ordinal().domain([0, 1, 2]).rangeRoundBands([0, 150], 1, 0.5);
    var crossColor = "rgba(231, 76, 60, 1.0)";
    var noughtColor = "rgba(41, 128, 185,1.0)";
    for (var row = 0; row < 3; row++) {
        for (var col = 0; col < 3; col++) {
            var cellType = tic.cell(row, col);
            if (cellType === "CROSS") {
                var cellSize = 150 / 11;
                svg.append("line")
                    .attr("x1", scale(col) - cellSize)
                    .attr("y1", scale(row) - cellSize)
                    .attr("x2", scale(col) + cellSize)
                    .attr("y2", scale(row) + cellSize)
                    .attr("stroke", crossColor)
                    .attr("stroke-width", 150 / 30);
                svg.append("line")
                    .attr("x1", scale(col) - cellSize)
                    .attr("y1", scale(row) + cellSize)
                    .attr("x2", scale(col) + cellSize)
                    .attr("y2", scale(row) - cellSize)
                    .attr("stroke", crossColor)
                    .attr("stroke-width", 150 / 30);
            } else if (cellType === "NOUGHT") {
                svg.append("circle")
                    .attr("cx", scale(col))
                    .attr("cy", scale(row))
                    .attr("r", 150 * 0.1)
                    .attr("fill", noughtColor);
            }
        }
    }
    return svgEl.outerHTML;
}()));
</script>

<h2>Generate the tree</h2>

<p>Define a root node of the tree:</p>

{% highlight javascript %}
var root = {
    game: tic
};
{% endhighlight %}

<p>
    Create an algorithm that will generate the tree. In this case we are using a depth-first search algorithm.
    Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. One starts at
    the root (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along
    each branch before backtracking.
</p>

{% highlight javascript %}
var depthFirstTreeGenerator = function(node) {
    var moves = node.game.moves();
    if (moves.length > 0) {
        node.children = [];
        for (var i = 0; i < moves.length; i++) {
            var newGameNode = { game: node.game.copy().move(i) };
            node.children.push(newGameNode);
            depthFirstTreeGenerator(newGameNode);
        }
    }
};
{% endhighlight %}

<p>And generate the tree by passing the root node to the algorithm:</p>

{% highlight javascript %}
depthFirstTreeGenerator(root);
{% endhighlight %}

<h2>Visualizing the game tree</h2>

{% highlight javascript %}
var diagonal = d3.svg.diagonal().projection(function(d) { return [d.x, d.y]; });

var svg = d3.select("#full-static-game-tree")
    .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .attr("style", "background-color: #eeeeee")
    .append("g")
    .attr("transform", "translate(" + margin.left + ", " + margin.top + ")");

var tree = d3.layout.tree().size([width, height]);

tree.separation(function() {
    return 2;
});

var nodes = tree(root);

var drawNodes = function() {

    // Draw edges
    svg.selectAll("path")
        .data(tree.links(nodes))
        .enter().append("path")
        .attr("d", diagonal)
        .attr("fill", "none")
        .attr("stroke", "#666666")
        .attr("stroke-width", 2);

    svg.selectAll("g.node-group")
        .data(nodes)
        .enter()
        .append("g")
        .attr("class", "node-group")
        .attr("transform", function(d) {
            return "translate(" + (d.x - 25) + ", " + (d.y - 25) + ")"
        });

    // Draw nodes
    svg.selectAll(".node-group")
        .each(function(node) {
            svgView.model = node.game;
            svgView.svg = d3.select(this);
            svgView.render();
        });

    // Resize game nodes
    svg.selectAll(".node-group")
        .attr("transform", function() {
            return this.getAttribute("transform") + " scale(0.6)";
        });

};

drawNodes();
{% endhighlight %}


<p>At two plies</p>

<div id="final-game-tree-2-ply"></div>

<p>At three plies:</p>

<div id="final-game-tree-3-ply"></div>

<p>At four plies:</p>

<div id="final-game-tree-4-ply"></div>

<!--<h2>Depth-first search</h2>-->

<!--<p>-->
    <!--Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. One starts at-->
    <!--the root (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along-->
    <!--each branch before backtracking.-->
<!--</p>-->

<!--<h3>Pre-order</h3>-->

<!--aasdfa-->

<!--<h3>In-order</h3>-->

<!--aasdfa-->

<!--<h3>Post-order</h3>-->

<!--aasdfa-->

<!--<h2>Breadth-first search</h2>-->

<!--<p>-->
    <!--In graph theory, breadth-first search (BFS) is a strategy for searching in a graph when search is limited to-->
    <!--essentially two operations: (a) visit and inspect a node of a graph; (b) gain access to visit the nodes that-->
    <!--neighbor the currently visited node.-->
<!--</p>-->

<!--<h2>Summary</h2>-->

<!--<p>-->
    <!--Some random summary here.-->
<!--</p>-->

<!--<h2>Generating random trees</h2>-->

<!--<p>-->
    <!--Random positions here. Add a button that generates the trees.-->
<!--</p>-->

<!--<h2>Play the game looking at the game tree?</h2>-->

<!--<p>This is interesting.</p>-->